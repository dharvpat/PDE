"""
Event classes for event-driven backtesting.

Provides the core event types that flow through the backtest engine:
    - MarketEvent: New market data available
    - SignalEvent: Trading signal generated by strategy
    - OrderEvent: Order placed for execution
    - FillEvent: Order filled/executed

Reference:
    Event-driven backtesting architecture as described in
    "Successful Algorithmic Trading" by Michael Halls-Moore
"""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, Optional


class EventType(Enum):
    """Types of events in backtesting."""

    MARKET = "MARKET"  # New market data available
    SIGNAL = "SIGNAL"  # Trading signal generated
    ORDER = "ORDER"  # Order placed
    FILL = "FILL"  # Order filled


class SignalType(Enum):
    """Types of trading signals."""

    LONG = "LONG"  # Enter long position
    SHORT = "SHORT"  # Enter short position
    EXIT_LONG = "EXIT_LONG"  # Exit long position
    EXIT_SHORT = "EXIT_SHORT"  # Exit short position
    EXIT = "EXIT"  # Exit all positions


class OrderType(Enum):
    """Types of orders."""

    MARKET = "MARKET"  # Market order (immediate execution)
    LIMIT = "LIMIT"  # Limit order (execute at limit price or better)
    STOP = "STOP"  # Stop order (trigger at stop price)
    STOP_LIMIT = "STOP_LIMIT"  # Stop-limit order


class Direction(Enum):
    """Order direction."""

    BUY = "BUY"
    SELL = "SELL"


@dataclass
class Event:
    """
    Base class for all events.

    Attributes:
        event_type: Type of the event
        timestamp: When the event occurred
    """

    event_type: EventType
    timestamp: datetime


@dataclass
class MarketEvent(Event):
    """
    Market data update event.

    Generated when new market data (price bar) is available.

    Attributes:
        symbol: Asset symbol (e.g., "SPY")
        price: Current price (typically close price)
        volume: Trading volume
        bid: Best bid price
        ask: Best ask price
        open: Open price
        high: High price
        low: Low price
        market_data: Additional market data (greeks, IV, etc.)
    """

    symbol: str
    price: float
    volume: float = 0.0
    bid: Optional[float] = None
    ask: Optional[float] = None
    open: Optional[float] = None
    high: Optional[float] = None
    low: Optional[float] = None
    market_data: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        """Set event type after initialization."""
        object.__setattr__(self, "event_type", EventType.MARKET)

    @property
    def mid_price(self) -> float:
        """Calculate mid price from bid/ask if available."""
        if self.bid is not None and self.ask is not None:
            return (self.bid + self.ask) / 2
        return self.price

    @property
    def spread(self) -> float:
        """Calculate bid-ask spread if available."""
        if self.bid is not None and self.ask is not None:
            return self.ask - self.bid
        return 0.0

    @property
    def spread_pct(self) -> float:
        """Calculate spread as percentage of mid price."""
        if self.price > 0:
            return self.spread / self.price
        return 0.0


@dataclass
class SignalEvent(Event):
    """
    Trading signal event.

    Generated by a strategy when it identifies a trading opportunity.

    Attributes:
        symbol: Asset symbol
        signal_type: Type of signal (LONG, SHORT, EXIT)
        strength: Signal strength/confidence [0, 1]
        strategy_id: ID of strategy that generated signal
        target_quantity: Target position size (optional)
        target_price: Target entry/exit price (optional)
        stop_loss: Stop loss price (optional)
        take_profit: Take profit price (optional)
        metadata: Additional signal information
    """

    symbol: str
    signal_type: SignalType
    strength: float
    strategy_id: str
    target_quantity: Optional[float] = None
    target_price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        """Set event type after initialization."""
        object.__setattr__(self, "event_type", EventType.SIGNAL)
        # Clamp strength to [0, 1]
        if self.strength < 0:
            object.__setattr__(self, "strength", 0.0)
        elif self.strength > 1:
            object.__setattr__(self, "strength", 1.0)


@dataclass
class OrderEvent(Event):
    """
    Order placement event.

    Generated when the portfolio manager decides to place an order.

    Attributes:
        symbol: Asset symbol
        order_type: Type of order (MARKET, LIMIT, STOP)
        quantity: Number of shares/contracts (always positive)
        direction: BUY or SELL
        limit_price: Limit price (for LIMIT and STOP_LIMIT orders)
        stop_price: Stop/trigger price (for STOP orders)
        strategy_id: Strategy that placed the order
        order_id: Unique order identifier
        time_in_force: Order validity (DAY, GTC, IOC, FOK)
    """

    symbol: str
    order_type: OrderType
    quantity: float
    direction: Direction
    limit_price: Optional[float] = None
    stop_price: Optional[float] = None
    strategy_id: str = "default"
    order_id: Optional[str] = None
    time_in_force: str = "DAY"

    def __post_init__(self):
        """Set event type after initialization."""
        object.__setattr__(self, "event_type", EventType.ORDER)
        # Ensure quantity is positive
        if self.quantity < 0:
            object.__setattr__(self, "quantity", abs(self.quantity))

    @property
    def notional_value(self) -> float:
        """Estimate notional value of order."""
        price = self.limit_price or self.stop_price or 0.0
        return self.quantity * price


@dataclass
class FillEvent(Event):
    """
    Order fill event.

    Generated when an order is executed (filled).

    Attributes:
        symbol: Asset symbol
        quantity: Filled quantity
        direction: BUY or SELL
        fill_price: Execution price
        commission: Commission paid
        slippage: Slippage cost (difference from expected price)
        strategy_id: Strategy that placed the order
        order_id: Original order ID
        exchange: Exchange where order was filled
    """

    symbol: str
    quantity: float
    direction: Direction
    fill_price: float
    commission: float
    slippage: float = 0.0
    strategy_id: str = "default"
    order_id: Optional[str] = None
    exchange: str = "SIMULATED"

    def __post_init__(self):
        """Set event type after initialization."""
        object.__setattr__(self, "event_type", EventType.FILL)

    @property
    def total_cost(self) -> float:
        """Calculate total execution cost (commission + slippage)."""
        return self.commission + self.slippage

    @property
    def notional_value(self) -> float:
        """Calculate notional value of fill."""
        return self.quantity * self.fill_price

    @property
    def cost_bps(self) -> float:
        """Calculate total cost in basis points."""
        if self.notional_value > 0:
            return (self.total_cost / self.notional_value) * 10000
        return 0.0
